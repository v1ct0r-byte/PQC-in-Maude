--- Specification of BIKE
--- Author: Víctor García Valero <vicgarv2@upv.es>

--- Module specifying basic datatypes and its operations used in BIKE
fmod DATA-TYPES is
    --- Supersort of all data
    sort Data . 
    --- Definition of type polynomial for our data
    sort Polynomial .

    --- We specify that polynomials are data
    subsort Polynomial < Data .

    --- Operator addition of polynomials
    op _p+_ : Polynomial Polynomial -> Polynomial [id: 0 assoc comm prec 33] .

    --- --- Operator multiplication of polynomials
    op _p*_ : Polynomial Polynomial -> Polynomial [id: 1 assoc comm prec 31] .

    vars P0 P1 P2 : Polynomial .

    --- Distrivutive property of polynomial product over polynomial addition
    eq (P0 p+ P1) p* P2 = (P0 p* P2) p+ (P1 p* P2) .

    --- Pair
    sort Pair .

    --- A Pair can be seen as a Polynomial divided in two parts
    subsort Pair < Polynomial .

    op [_,_] : Data Data -> Pair [ctor] .

    vars D1 D2 : Data .

    --- First element of Pair
    op first : Pair -> Data .
    eq first([D1,D2]) = D1 .
    --- Second element of Pair
    op second : Pair -> Data .
    eq second([D1,D2]) = D2 .

    --- Inverse operation over polynomials
    op inv : Polynomial -> Polynomial .

    eq P0 p* inv(P0) = 1 .
endfm

--- Module to specify all the hash functions that are used in the steps of BIKE KEM
fmod BIKE-HASH-OPERATIONS is
    protecting DATA-TYPES .

    --- H recieves a random polynomial and returns a hash of it (which is a pair of polynomials)
    op H : Polynomial -> Pair [ctor] .
    op K : Polynomial Pair -> Polynomial [ctor] .
    op L : Pair -> Polynomial [ctor] .
endfm

--- Module to specifiy basic operations on data
fmod ENCRYPTION is
    protecting DATA-TYPES .
    protecting NAT .

    subsort Nat < Data .

    var D : Data .

    --- XOR
    op _xorD_ : Data Data -> Data [assoc comm] .
    eq D xorD 0 = D .
    eq D xorD D = 0 .
endfm

--- Module to represent the data and operations handled during KEYGEN
fmod BIKE-CPAPKE-KEYGEN is
    protecting DATA-TYPES .

    --- Constant value representing the h_i sampled from the private key space H_w
    ops h0 h1 h0' h1' : -> Polynomial .

    --- Constant value representing the sigma obtained in step 3
    ops sigma sigma' : -> Polynomial .
endfm

--- Module to represent the operations and data handled during ENC
fmod BIKE-CPAPKE-ENC is
    protecting DATA-TYPES .
    protecting BIKE-HASH-OPERATIONS .
    protecting ENCRYPTION .

    --- Messages randomply generated by a principal
    ops m1 m2 : -> Polynomial .

    --- Errors generated from H(M1)
    ops e0 e1 : -> Polynomial .
    eq H(m1) = [e0,e1] .

    --- Errors generated from H(M2)
    ops e0' e1' : -> Polynomial .
    eq H(m2) = [e0',e1'] .

    --- Operator to represent the shared key
    ops k k' : -> Polynomial .
    var C : Pair .
    --- Key generated from K(m1,c)
    eq K(m1,C) = k .
    --- Key generated from K(m2,c)
    eq K(m2,C) = k' .
endfm

--- Module to represent the operations and data handled during DEC
--- Its main purpouse is to demonstrate that the computed key is
--- the one that was computed in the other side using PK and C
fmod BIKE-CPAPKE-DEC is
    protecting DATA-TYPES .

    --- Operator to represent the decoder used (Black-Gray-Flip)
    op decoder : Polynomial Polynomial Polynomial -> Pair .
    
    vars P0 P1 P2 P3 : Polynomial .

    --- We only consider the perfect case where the obtained errors are the originals
    eq decoder((P0 p+ P1 p* P2 p* inv(P3)) p* P3, P3, P2) = [P0, P1] .
    eq decoder(P0 p* P1 p+ P2 p* P3, P1, P3) = [P0,P2] .
endfm

--- Specification of the system upon BIKE will work
fmod MODEL-CONFIGURATION is
    protecting DATA-TYPES .

    --- SORTS---------------------------------
    sorts Identifier Content Principal Principals . 
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs .
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    --- We distinguish between public and secret keys, both being keys in the end
    sorts PKey SKey .

    ---We define keys as a type of content
    subsorts Polynomial < PKey SKey < Key < Content .

    --- We also declare that a pair is content
    subsort Pair < Content .

    --- Sort for the State of our system
    sort GlobalState .

    --- OPERATORS----------------------------
    --- Empty group of keys
    op emptyK : -> Keys .
    --- Group of keys
    op _;_ : Keys Keys -> Keys [assoc comm id: emptyK] .

    var K : Key .
    vars KS1 KS2 : Keys .

    --- Operation to check the precence of a key in a participant
    op _in_ : Key Keys -> Bool .
    eq K in (KS1 ; K ; KS2) = true .
    eq K in (KS1) = false [owise] .

    --- Operator to represent the relation of a public key and a principal
    op publicKey : Identifier Key -> PKey .

    --- Operator to represent the relation of a secret key and a principal
    op secretKey : Identifier Key -> SKey .

    --- Operator to represent the shared key with a participant
    op sharedKey : Identifier Key -> SKey [format (g! o)] .

    --- Posible states for a message delivering PK
    ops sentPK receivedPK : -> MsgState .
    --- Posible states for a message delivering C
    ops sentC receivedC : -> MsgState .

    --- Empty content
    op emptyC : -> Content .
    --- Group of contents
    op __ : Content Content -> Content [assoc comm id: emptyC] .

    vars C CONT1 CONT2 : Content .

    --- Operation to check the contents of a participant
    op _in_ : Content Content -> Bool .
    eq C in (CONT1 C CONT2) = true .
    eq C in (CONT1) = false [owise] .

    --- Structure of a message
    --- Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .

    --- Group of messsages
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM format (d nt d)] .

    var M : Msg .
    vars MS1 MS2 : Msgs .
    
    --- Operation to check the network
    op _in_ : Msg Msgs -> Bool .

    eq M in (MS1 M MS2) = true .
    eq M in (MS1) = false [owise] .

    --- Defintion of our three main participants followiing the literature
    ops Alice Eve Bob : ->  Identifier [ctor] .

    --- Definition of the default participant
    op none : -> Identifier [ctor] .

    --- Operator to assign a Ciphered text to a participant
    op cI : Identifier Pair -> Content .

    --- Operator to mark the current participant to whom the key exchange is happening
    op peer : Identifier -> Content .

    --- Definition of the components of a Principal
    --- (idenifier [keys] content)
    op _[_]_ : Identifier Keys Content -> Principal [ctor] .

    --- Group of principals
    op __ : Principal Principal -> Principals [assoc comm format (d n d)] .

    --- Global state composed by Samples, Principals and a Network with messages
    op {_}<_>net(_) : Content Principals Msgs -> GlobalState [ctor format (n d d n n n d d d d)] .
endfm

--- Protocol/mechanism samples and behaviour
mod BIKE is
    --- IMPORTS-------------------------------
    protecting DATA-TYPES .
    protecting BIKE-HASH-OPERATIONS .
    protecting ENCRYPTION .
    protecting BIKE-CPAPKE-KEYGEN .
    protecting BIKE-CPAPKE-ENC .
    protecting BIKE-CPAPKE-DEC .
    protecting MODEL-CONFIGURATION .

    --- Group of polynomials sigma that can be sampled
    op sigmas : Content -> Content .

    --- Group of messages m that can be sampled
    op ms : Content -> Content .

    --- Group of polynomials h that can be sampled; They come in pairs
    op hs : Content -> Content .

    --- Operator to assign a polynomial 'sigma' to a participant
    op sigmaI : Identifier Polynomial -> Content .

    --- Operator to assign a message to a participant
    op mI : Identifier Polynomial -> Content .

    --- Operator to assign a random pair of hs to a participant
    op hI : Identifier Pair -> Content .

    --- Initial state-------------------------------------------------------------------------------------------------------------
    ops init1 init2 : -> GlobalState .
    eq init1 = {sigmas(sigma) ms(m1) hs([h0,h1])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .
    eq init2 = {sigmas(sigma sigma') ms(m1 m2) hs([h0,h1] [h0',h1'])} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .

    --- RULES-------------------------------------------------------------------------------------------------------------
    
    vars ID1 ID2 ID3 : Identifier .
    var PS : Principals .
    vars MSGS MSGS' : Msgs .
    vars SK SK' : SKey .
    vars PK PK' : PKey .
    vars Cs Cs' Hs Es : Pair .
    vars C0 C1 : Polynomial .
    vars E0 E1 : Polynomial .
    var M : Polynomial .
    vars KS1 KS2 KS3 : Keys .
    vars SAM1 SAM2 : Data .
    vars CONT1 CONT2 CONT3 : Content .

    --- For now the protocol only starts when the participant can sample necesary values for keygen

    crl [KeyGen] :  {sigmas(SAM1 CONT1) hs(SAM2 CONT2) CONT3} < (ID1[emptyK]peer(none)) PS >net(MSGS) 
                    => 
                    {sigmas(CONT1) hs(CONT2) CONT3} < (ID1[publicKey(ID1, PK)]peer(none) sigmaI(ID1,SAM1) hI(ID1, SAM2)) PS >net(MSGS) 
                    if PK := (second(SAM2) p* inv(first(SAM2))) .

    --- The public key is sent
    crl [SendPK] :  {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]peer(none) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS)
                    =>
                    {CONT3} < (ID1[KS1]peer(ID2) CONT1) (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})
                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\
                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .

    rl [ReceivePK] :    {CONT3} < (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)} MSGS')
                        =>
                        {CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS msg{(ID1, ID2)[receivedPK](PK)} MSGS') .
    
    --- The public key is consumed to generate a shared key
    crl [Enc] : {ms(SAM1 CONT1) CONT3} < (ID2[publicKey(ID1, PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS)
                =>
                {ms(CONT1) CONT3} < (ID2[sharedKey(ID1, SK) ; KS2]peer(ID1) mI(ID2, SAM1) cI(ID1, Cs) CONT2) PS >net(MSGS)
                if  ID1 =/= ID2 /\
                    Es := H(SAM1) /\
                    E0 := first(Es) /\
                    E1 := second(Es) /\
                    Cs := [(E0 p+ (E1 p* (PK))), (SAM1 xorD L(Es))] /\
                    SK := K(SAM1, Cs) .

    --- The ciphered text is sent
    crl [SendCiph] :    {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(ID1) cI(ID1, Cs) CONT2) PS >net(MSGS)
                        =>
                        {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] peer(none) CONT2) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)}) 
                        if  ID1 =/= ID2 /\
                            (msg{(ID2, ID1)[sentC](Cs)}) in MSGS == false /\ 
                            (msg{(ID2, ID1)[receivedC](Cs)}) in MSGS == false .
    
    rl [ReceiveCiph] :  {CONT3} < (ID1[KS1]peer(ID2) CONT1) PS >net(MSGS msg{(ID2, ID1)[sentC](Cs)} MSGS') 
                        =>
                        {CONT3} < (ID1[KS1]peer(ID2) cI(ID1, Cs) CONT1) PS >net(MSGS msg{(ID2, ID1)[receivedC](Cs)} MSGS')  .

    --- The ciphered text is consumed to generate the shared key
    crl [Dec] :  {CONT3}< (ID1[KS1] peer(ID2) hI(ID1, Hs) cI(ID1, Cs) CONT1) PS >net(MSGS)
                =>
                {CONT3}< (ID1[sharedKey(ID2, SK) ; KS1] peer(none) hI(ID1, Hs) CONT1) PS >net(MSGS) 
                if  ID1 =/= ID2 /\
                    ID2 =/= none /\
                    Es := decoder(first(Cs) p* first(Hs), first(Hs), second(Hs)) /\
                    E0 := first(Es) /\
                    E1 := second(Es) /\
                    M := second(Cs) xorD L(Es) /\
                    SK := K(M, Cs) .

    --- Specific intruder behaivour
    crl [Intercept1] :  {CONT3}< (Eve[publicKey(Eve, PK') ; KS1]peer(none) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK)}) 
                        =>
                        {CONT3}< (Eve[publicKey(ID1,PK) ; KS1]peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK](PK')}) 
                        if  ID1 =/= Eve /\
                            ID2 =/= Eve /\
                            ID1 =/= ID2 /\
                            PK =/= PK' /\
                            (publicKey(ID1,PK)) in KS1 == false .

    crl [Intercept2] :  {CONT3}< (Eve[KS1]cI(ID2,Cs') peer(ID2) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs)}) 
                        =>
                        {CONT3}< (Eve[KS1]cI(Eve,Cs) peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC](Cs')}) 
                        if  ID1 =/= Eve /\
                            ID2 =/= Eve /\
                            ID1 =/= ID2 /\
                            Cs =/= Cs' /\
                            (cI(ID1,Cs)) in CONT1 == false .
endm